"""Vulnerability scanning and assessment module."""

import logging
import subprocess
import json
from pathlib import Path
from typing import List, Dict, Any, Optional

from irvs.core.result import VerificationResult, Finding, Severity
from irvs.core.config import VulnerabilityConfig


logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Scans for known vulnerabilities using multiple data sources.

    Integrates with:
    - National Vulnerability Database (NVD)
    - OSV (Open Source Vulnerabilities)
    - GitHub Security Advisories
    - Grype, Trivy, and other scanners
    """

    def __init__(self, config: VulnerabilityConfig):
        """Initialize vulnerability scanner."""
        self.config = config

    def scan_package(self, package_path: str) -> VerificationResult:
        """
        Scan a package for known vulnerabilities.

        Args:
            package_path: Path to package

        Returns:
            VerificationResult with vulnerability findings
        """
        result = VerificationResult()

        if not self.config.enabled:
            logger.info("Vulnerability scanning is disabled")
            return result

        logger.info(f"Scanning for vulnerabilities: {package_path}")

        # Try Grype first
        grype_findings = self._scan_with_grype(package_path)
        result.findings.extend(grype_findings)

        # Try Trivy if Grype unavailable
        if not grype_findings:
            trivy_findings = self._scan_with_trivy(package_path)
            result.findings.extend(trivy_findings)

        # Apply configuration filters
        result.findings = self._filter_findings(result.findings)

        return result

    def scan_sbom(self, sbom_path: str) -> VerificationResult:
        """
        Scan an SBOM for vulnerabilities.

        Args:
            sbom_path: Path to SBOM file

        Returns:
            VerificationResult with vulnerability findings
        """
        result = VerificationResult()

        if not self.config.enabled:
            return result

        logger.info(f"Scanning SBOM for vulnerabilities: {sbom_path}")

        # Grype can scan SBOMs directly
        grype_findings = self._scan_sbom_with_grype(sbom_path)
        result.findings.extend(grype_findings)

        result.findings = self._filter_findings(result.findings)

        return result

    def _scan_with_grype(self, target_path: str) -> List[Finding]:
        """Scan using Grype vulnerability scanner."""
        findings = []

        try:
            result = subprocess.run(
                ['grype', target_path, '-o', 'json'],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_grype_output(data, target_path)
                logger.info(f"Grype found {len(findings)} vulnerabilities")
            else:
                logger.warning(f"Grype scan failed: {result.stderr}")

        except FileNotFoundError:
            logger.debug("Grype not installed")
        except subprocess.TimeoutExpired:
            logger.error("Grype scan timed out")
        except json.JSONDecodeError:
            logger.error("Failed to parse Grype output")
        except Exception as e:
            logger.error(f"Error running Grype: {e}")

        return findings

    def _scan_sbom_with_grype(self, sbom_path: str) -> List[Finding]:
        """Scan SBOM using Grype."""
        findings = []

        try:
            result = subprocess.run(
                ['grype', f'sbom:{sbom_path}', '-o', 'json'],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_grype_output(data, sbom_path)

        except FileNotFoundError:
            logger.debug("Grype not installed")
        except Exception as e:
            logger.error(f"Error scanning SBOM with Grype: {e}")

        return findings

    def _parse_grype_output(self, data: Dict[str, Any], source: str) -> List[Finding]:
        """Parse Grype JSON output into findings."""
        findings = []

        matches = data.get('matches', [])
        for match in matches:
            vulnerability = match.get('vulnerability', {})
            artifact = match.get('artifact', {})

            cve_id = vulnerability.get('id', 'UNKNOWN')
            severity = self._map_severity(vulnerability.get('severity', 'UNKNOWN'))
            description = vulnerability.get('description', 'No description available')

            # Get CVSS score
            cvss_score = None
            cvss_data = vulnerability.get('cvss', [])
            if cvss_data:
                cvss_score = cvss_data[0].get('metrics', {}).get('baseScore')

            # Get fix information
            fix_versions = match.get('vulnerability', {}).get('fix', {}).get('versions', [])
            remediation = None
            if fix_versions:
                remediation = f"Upgrade to version: {', '.join(fix_versions)}"

            finding = Finding(
                severity=severity,
                category="vulnerability",
                title=f"Vulnerability {cve_id} in {artifact.get('name', 'unknown')}",
                description=description,
                remediation=remediation,
                cve_ids=[cve_id],
                cvss_score=cvss_score,
                affected_component=f"{artifact.get('name')}@{artifact.get('version')}",
                metadata={
                    "scanner": "grype",
                    "package": artifact.get('name'),
                    "version": artifact.get('version'),
                    "source": source,
                    "data_source": vulnerability.get('dataSource', 'unknown')
                }
            )

            findings.append(finding)

        return findings

    def _scan_with_trivy(self, target_path: str) -> List[Finding]:
        """Scan using Trivy vulnerability scanner."""
        findings = []

        try:
            result = subprocess.run(
                ['trivy', 'fs', '--format', 'json', target_path],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_trivy_output(data, target_path)
                logger.info(f"Trivy found {len(findings)} vulnerabilities")

        except FileNotFoundError:
            logger.debug("Trivy not installed")
        except subprocess.TimeoutExpired:
            logger.error("Trivy scan timed out")
        except Exception as e:
            logger.error(f"Error running Trivy: {e}")

        return findings

    def _parse_trivy_output(self, data: Dict[str, Any], source: str) -> List[Finding]:
        """Parse Trivy JSON output into findings."""
        findings = []

        results = data.get('Results', [])
        for result in results:
            vulnerabilities = result.get('Vulnerabilities', [])

            for vuln in vulnerabilities:
                cve_id = vuln.get('VulnerabilityID', 'UNKNOWN')
                severity = self._map_trivy_severity(vuln.get('Severity', 'UNKNOWN'))
                description = vuln.get('Description', vuln.get('Title', 'No description'))

                # Get CVSS score
                cvss_score = None
                if 'CVSS' in vuln:
                    for cvss_type, cvss_data in vuln['CVSS'].items():
                        if 'V3Score' in cvss_data:
                            cvss_score = cvss_data['V3Score']
                            break

                # Get fix information
                remediation = None
                if vuln.get('FixedVersion'):
                    remediation = f"Upgrade to version: {vuln['FixedVersion']}"

                finding = Finding(
                    severity=severity,
                    category="vulnerability",
                    title=f"Vulnerability {cve_id} in {vuln.get('PkgName', 'unknown')}",
                    description=description,
                    remediation=remediation,
                    cve_ids=[cve_id],
                    cvss_score=cvss_score,
                    affected_component=f"{vuln.get('PkgName')}@{vuln.get('InstalledVersion')}",
                    metadata={
                        "scanner": "trivy",
                        "package": vuln.get('PkgName'),
                        "version": vuln.get('InstalledVersion'),
                        "source": source
                    }
                )

                findings.append(finding)

        return findings

    def _map_severity(self, severity_str: str) -> Severity:
        """Map vulnerability severity string to Severity enum."""
        severity_str = severity_str.upper()

        mapping = {
            'CRITICAL': Severity.CRITICAL,
            'HIGH': Severity.HIGH,
            'MEDIUM': Severity.MEDIUM,
            'LOW': Severity.LOW,
            'NEGLIGIBLE': Severity.INFO,
            'UNKNOWN': Severity.INFO
        }

        return mapping.get(severity_str, Severity.MEDIUM)

    def _map_trivy_severity(self, severity_str: str) -> Severity:
        """Map Trivy severity to Severity enum."""
        return self._map_severity(severity_str)

    def _filter_findings(self, findings: List[Finding]) -> List[Finding]:
        """Filter findings based on configuration."""
        filtered = []

        for finding in findings:
            # Skip ignored CVEs
            if finding.cve_ids:
                if any(cve in self.config.ignore_cves for cve in finding.cve_ids):
                    logger.debug(f"Ignoring CVE: {finding.cve_ids}")
                    continue

            # Filter by CVSS score
            if finding.cvss_score and finding.cvss_score > self.config.max_cvss_score:
                filtered.append(finding)
                continue

            filtered.append(finding)

        return filtered

"""Vulnerability scanning and assessment module."""

import logging
import subprocess
import json
import shutil
from pathlib import Path
from typing import List, Dict, Any, Optional

from irvs.core.result import VerificationResult, Finding, Severity
from irvs.core.config import VulnerabilityConfig


logger = logging.getLogger(__name__)


class VulnerabilityScannerError(Exception):
    """Raised when vulnerability scanner encounters a critical error."""
    pass


class VulnerabilityScanner:
    """
    Scans for known vulnerabilities using multiple data sources.

    Integrates with:
    - National Vulnerability Database (NVD)
    - OSV (Open Source Vulnerabilities)
    - GitHub Security Advisories
    - Grype, Trivy, and other scanners
    """

    def __init__(self, config: VulnerabilityConfig):
        """Initialize vulnerability scanner."""
        self.config = config
        self._tools_checked = False
        self._available_tools = []

    def _check_available_tools(self) -> List[str]:
        """
        Check which vulnerability scanning tools are available.

        Returns:
            List of available tool names

        Raises:
            VulnerabilityScannerError: If no scanning tools are available
        """
        if self._tools_checked:
            return self._available_tools

        available = []

        if shutil.which('grype'):
            available.append('grype')
            logger.debug("Grype is available")

        if shutil.which('trivy'):
            available.append('trivy')
            logger.debug("Trivy is available")

        self._available_tools = available
        self._tools_checked = True

        if not available:
            raise VulnerabilityScannerError(
                "No vulnerability scanning tools found. Install at least one:\n"
                "  Grype: curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh\n"
                "  Trivy: curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh"
            )

        return available

    def scan_package(self, package_path: str) -> VerificationResult:
        """
        Scan a package for known vulnerabilities.

        Args:
            package_path: Path to package

        Returns:
            VerificationResult with vulnerability findings

        Raises:
            VulnerabilityScannerError: If no scanning tools are available
        """
        result = VerificationResult()

        if not self.config.enabled:
            logger.info("Vulnerability scanning is disabled")
            return result

        # Check for available tools (raises error if none found)
        available_tools = self._check_available_tools()

        logger.info(f"Scanning for vulnerabilities: {package_path}")
        logger.info(f"Available scanners: {', '.join(available_tools)}")

        # Try Grype first
        if 'grype' in available_tools:
            grype_findings = self._scan_with_grype(package_path)
            result.findings.extend(grype_findings)

        # Try Trivy if Grype unavailable or found no results
        if 'trivy' in available_tools and not result.findings:
            trivy_findings = self._scan_with_trivy(package_path)
            result.findings.extend(trivy_findings)

        # Apply configuration filters
        result.findings = self._filter_findings(result.findings)

        return result

    def scan_sbom(self, sbom_path: str) -> VerificationResult:
        """
        Scan an SBOM for vulnerabilities.

        Args:
            sbom_path: Path to SBOM file

        Returns:
            VerificationResult with vulnerability findings

        Raises:
            VulnerabilityScannerError: If no scanning tools are available
        """
        result = VerificationResult()

        if not self.config.enabled:
            return result

        # Check for available tools
        available_tools = self._check_available_tools()

        logger.info(f"Scanning SBOM for vulnerabilities: {sbom_path}")

        # Grype can scan SBOMs directly
        if 'grype' in available_tools:
            grype_findings = self._scan_sbom_with_grype(sbom_path)
            result.findings.extend(grype_findings)
        else:
            logger.warning("Grype not available for SBOM scanning. Install Grype for best results.")

        result.findings = self._filter_findings(result.findings)

        return result

    def _scan_with_grype(self, target_path: str) -> List[Finding]:
        """Scan using Grype vulnerability scanner."""
        findings = []

        try:
            result = subprocess.run(
                ['grype', target_path, '-o', 'json'],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_grype_output(data, target_path)
                logger.info(f"Grype found {len(findings)} vulnerabilities")
            else:
                logger.warning(f"Grype scan failed (exit code {result.returncode}): {result.stderr}")

        except subprocess.TimeoutExpired:
            logger.error("Grype scan timed out after 5 minutes")
            raise VulnerabilityScannerError("Grype scan timed out. Target may be too large.")
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse Grype output: {e}")
            raise VulnerabilityScannerError(f"Invalid JSON from Grype: {e}")
        except Exception as e:
            logger.error(f"Error running Grype: {e}")
            raise VulnerabilityScannerError(f"Grype execution failed: {e}")

        return findings

    def _scan_sbom_with_grype(self, sbom_path: str) -> List[Finding]:
        """Scan SBOM using Grype."""
        findings = []

        try:
            result = subprocess.run(
                ['grype', f'sbom:{sbom_path}', '-o', 'json'],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_grype_output(data, sbom_path)
            else:
                logger.warning(f"Grype SBOM scan failed: {result.stderr}")

        except subprocess.TimeoutExpired:
            raise VulnerabilityScannerError("Grype SBOM scan timed out")
        except json.JSONDecodeError as e:
            raise VulnerabilityScannerError(f"Invalid JSON from Grype SBOM scan: {e}")
        except Exception as e:
            logger.error(f"Error scanning SBOM with Grype: {e}")
            raise VulnerabilityScannerError(f"Grype SBOM scan failed: {e}")

        return findings

    def _parse_grype_output(self, data: Dict[str, Any], source: str) -> List[Finding]:
        """Parse Grype JSON output into findings."""
        findings = []

        matches = data.get('matches', [])
        for match in matches:
            vulnerability = match.get('vulnerability', {})
            artifact = match.get('artifact', {})

            cve_id = vulnerability.get('id', 'UNKNOWN')
            severity = self._map_severity(vulnerability.get('severity', 'UNKNOWN'))
            description = vulnerability.get('description', 'No description available')

            # Get CVSS score
            cvss_score = None
            cvss_data = vulnerability.get('cvss', [])
            if cvss_data:
                cvss_score = cvss_data[0].get('metrics', {}).get('baseScore')

            # Get fix information
            fix_versions = match.get('vulnerability', {}).get('fix', {}).get('versions', [])
            remediation = None
            if fix_versions:
                remediation = f"Upgrade to version: {', '.join(fix_versions)}"

            finding = Finding(
                severity=severity,
                category="vulnerability",
                title=f"Vulnerability {cve_id} in {artifact.get('name', 'unknown')}",
                description=description,
                remediation=remediation,
                cve_ids=[cve_id],
                cvss_score=cvss_score,
                affected_component=f"{artifact.get('name')}@{artifact.get('version')}",
                metadata={
                    "scanner": "grype",
                    "package": artifact.get('name'),
                    "version": artifact.get('version'),
                    "source": source,
                    "data_source": vulnerability.get('dataSource', 'unknown')
                }
            )

            findings.append(finding)

        return findings

    def _scan_with_trivy(self, target_path: str) -> List[Finding]:
        """Scan using Trivy vulnerability scanner."""
        findings = []

        try:
            result = subprocess.run(
                ['trivy', 'fs', '--format', 'json', target_path],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                findings = self._parse_trivy_output(data, target_path)
                logger.info(f"Trivy found {len(findings)} vulnerabilities")
            else:
                logger.warning(f"Trivy scan failed (exit code {result.returncode}): {result.stderr}")

        except subprocess.TimeoutExpired:
            logger.error("Trivy scan timed out after 5 minutes")
            raise VulnerabilityScannerError("Trivy scan timed out. Target may be too large.")
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse Trivy output: {e}")
            raise VulnerabilityScannerError(f"Invalid JSON from Trivy: {e}")
        except Exception as e:
            logger.error(f"Error running Trivy: {e}")
            raise VulnerabilityScannerError(f"Trivy execution failed: {e}")

        return findings

    def _parse_trivy_output(self, data: Dict[str, Any], source: str) -> List[Finding]:
        """Parse Trivy JSON output into findings."""
        findings = []

        results = data.get('Results', [])
        for result in results:
            vulnerabilities = result.get('Vulnerabilities', [])

            for vuln in vulnerabilities:
                cve_id = vuln.get('VulnerabilityID', 'UNKNOWN')
                severity = self._map_trivy_severity(vuln.get('Severity', 'UNKNOWN'))
                description = vuln.get('Description', vuln.get('Title', 'No description'))

                # Get CVSS score
                cvss_score = None
                if 'CVSS' in vuln:
                    for cvss_type, cvss_data in vuln['CVSS'].items():
                        if 'V3Score' in cvss_data:
                            cvss_score = cvss_data['V3Score']
                            break

                # Get fix information
                remediation = None
                if vuln.get('FixedVersion'):
                    remediation = f"Upgrade to version: {vuln['FixedVersion']}"

                finding = Finding(
                    severity=severity,
                    category="vulnerability",
                    title=f"Vulnerability {cve_id} in {vuln.get('PkgName', 'unknown')}",
                    description=description,
                    remediation=remediation,
                    cve_ids=[cve_id],
                    cvss_score=cvss_score,
                    affected_component=f"{vuln.get('PkgName')}@{vuln.get('InstalledVersion')}",
                    metadata={
                        "scanner": "trivy",
                        "package": vuln.get('PkgName'),
                        "version": vuln.get('InstalledVersion'),
                        "source": source
                    }
                )

                findings.append(finding)

        return findings

    def _map_severity(self, severity_str: str) -> Severity:
        """Map vulnerability severity string to Severity enum."""
        severity_str = severity_str.upper()

        mapping = {
            'CRITICAL': Severity.CRITICAL,
            'HIGH': Severity.HIGH,
            'MEDIUM': Severity.MEDIUM,
            'LOW': Severity.LOW,
            'NEGLIGIBLE': Severity.INFO,
            'UNKNOWN': Severity.INFO
        }

        return mapping.get(severity_str, Severity.MEDIUM)

    def _map_trivy_severity(self, severity_str: str) -> Severity:
        """Map Trivy severity to Severity enum."""
        return self._map_severity(severity_str)

    def _filter_findings(self, findings: List[Finding]) -> List[Finding]:
        """Filter findings based on configuration."""
        filtered = []

        for finding in findings:
            # Skip ignored CVEs
            if finding.cve_ids:
                if any(cve in self.config.ignore_cves for cve in finding.cve_ids):
                    logger.debug(f"Ignoring CVE: {finding.cve_ids}")
                    continue

            # Filter by CVSS score
            if finding.cvss_score and finding.cvss_score > self.config.max_cvss_score:
                filtered.append(finding)
                continue

            filtered.append(finding)

        return filtered
